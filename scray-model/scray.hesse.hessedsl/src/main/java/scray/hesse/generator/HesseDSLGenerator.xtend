/*
 * generated by Xtext
 */
package scray.hesse.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import scray.hesse.hesseDSL.Model
import scray.hesse.hesseDSL.SupportedPlatforms
import scray.hesse.hesseDSL.SupportedDBMSSystems
import scray.hesse.hesseDSL.MaterializedViewStatement

/**
 * Generates code from hesse files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class HesseDSLGenerator implements IGenerator {
	
	// default platform to generate in case it has not been specified
	public static val DEFAULT_PLATFORM = SupportedPlatforms.HADOOP;
	
	// default platform to generate in case it has not been specified
	public static val DEFAULT_DBMS = SupportedDBMSSystems.CASSANDRA;
	
	/**
	 * main generator method, handling Hesse documents
	 */
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		val state = new GeneratorState(fsa)
		
		for(model: resource.allContents.toIterable.filter(typeof(Model))) {
			
			
			// extract Header information
			val headerInfo = new HeaderInformation(model.header)
			
			// walk over all our materialized views we need to generate
			model.bodyStatements.forEach [ view |
				if(view instanceof MaterializedViewStatement) {
	            	if(headerInfo.platform == SupportedPlatforms.HADOOP) {
    	        		state.hadoopGenerator.doGenerate(state, headerInfo, view as MaterializedViewStatement, model.bodyStatements)
        	    	}
				}
			]
			
		}
//		fsa.generateFile('greetings.txt', 'People to greet: ' + 
//			resource.allContents
//				.filter(typeof(Greeting))
//				.map[name]
//				.join(', '))
	}
	
}
